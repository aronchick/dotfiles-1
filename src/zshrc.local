#-----------VARS----------------------

export SHELL='/bin/zsh'
export EDITOR='vim'
export VISUAL='vim'
export CDPATH='.:~:~/src/'
export GOPATH=$HOME
export RSYNC_RSH=ssh
export JAVA_HOME='/usr/java/latest'
export HISTFILE=$HOME/.dotfiles/src/.zhistory
export WORKON_HOME=$HOME/.virtualenvs
export PIP_VIRTUALENV_BASE=$WORKON_HOME

#------------OPTIONS------------------

setopt DVORAK                    # use dvorak keyboard layout for misspelled suggestions
setopt extended_glob             # more glob features
setopt extended_history          # Save timestamps with history
setopt hist_no_store             # Don't store history commands
setopt hist_save_no_dups         # Don't save duplicate history entries
setopt hist_ignore_all_dups      # Ignore old command duplicates (in current session)
setopt inc_append_history        # Append history immediately

#------------ALIASES------------------

# Directory listing

alias ll='ls -AlFh'
alias la='ls -A'
alias l='ls -CF'
alias latr='ls -lAtr'
alias lla='ll -A'       
alias l1='ls -1A'       # All files in 1 column
alias llg'll | grep'

# fasd
alias a='fasd -a'        # any
alias s='fasd -si'       # show / search / select
alias d='fasd -d'        # directory
alias f='fasd -f'        # file
alias sd='fasd -sid'     # interactive directory selection
alias sf='fasd -sif'     # interactive file selection
alias z='fasd_cd -d'     # cd, same functionality as j in autojump
alias zz='fasd_cd -d -i' # cd with interactive selection

# Easier navigation: .., ..., -
alias ..='cd ..'
alias ....='cd ../..'
alias xxx='exit'
alias :q='exit'

# File size
alias fs="stat -f '%z bytes'"
alias df="df -h"
alias du='du -ch'

if (( $+commands[subscription-manager] )) ; then
    alias sm="s subscription-manager"
fi

# MISC commands
alias gtfo="/dev/null"
alias stfu="/dev/null"
alias wtf="/dev/urandom"
alias mount='mount | column -t'
alias psg="ps aux | grep -v grep | grep -i -e VSZ -e"
alias lsg="s lsof | grep"
alias lvim='vim -c "normal '\''0"'
alias v='vim'
alias lmsg='s less +F /var/log/messages'
alias dmsg='less +F /var/log/dmesg'
alias -g H='| head'
alias -g L='| less'
alias -g G='| grep'
alias df="df -h"
alias du='du -ch'
alias rpg="rpm -qa | grep -i"
alias ylist='yum list --showduplicates'
alias ygroups="yum groupinfo '*' | less +/"
alias s="SHELL=/bin/zsh sudo -s "
alias curl-trace='curl -w "@${HOME}/.dotfiles/ln/curl-format" -o /dev/null -s'

# docker
alias d='s docker'
alias dl='d logs -f'
alias db='d build'
alias dm='docker-machine'
alias ds='docker-swarm'
alias dc='docker-compose'
alias dr='d run'
alias dpid="d inspect --format '{{ .State.Pid }}' "
alias dip="d inspect --format '{{ .NetworkSettings.IPAddress }}' "

# *ctl
alias sc='s systemctl'
alias jc='s journalctl'
alias mc='s machinectl'
alias kc='kubectl'

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# SSH aliases
# setup worktunnel in .ssh/config
alias sshwt='ssh -A -t worktunnel ssh -A -t'
# setup hometunnel is .ssh/config
alias sshht='ssh -A -t hometunnel ssh -A -t'

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# Key binds
# Use Ctrl+r even if I'm using vi key bindings
bindkey '^R' history-incremental-search-backward
bindkey '^a' beginning-of-line
bindkey '^e' end-of-line
# ^S and ^Q cause problems and I don't use them. Disable stty stop.
stty stop ""
stty start ""
bindkey -M vicmd k vi-up-line-or-history
bindkey -M vicmd j vi-down-line-or-history

#------------FUNCTIONS----------------

# docker functions
function de() { docker exec -it "$@" /bin/bash; }

dme() { eval "$(docker-machine env $1)"; }
dmes() { eval "$(docker-machine env --swarm $1)"; }
dmip() { export DOCKER_MACHINE_IP=`dm ip $DOCKER_MACHINE_NAME`; echo $DOCKER_MACHINE_IP; }

drm() { docker rm -v $(docker ps -aq -f status=exited); }
drmf() { docker rm -f -v $(docker ps -aq); }
drmi() { docker rmi $(docker images -q -f dangling=true); }

# apt-history
function apt-history(){
      case "$1" in
        install)
              cat /var/log/dpkg.log | grep 'install '
              ;;
        upgrade|remove)
              cat /var/log/dpkg.log | grep $1
              ;;
        rollback)
              cat /var/log/dpkg.log | grep upgrade | \
                  grep "$2" -A10000000 | \
                  grep "$3" -B10000000 | \
                  awk '{print $4"="$5}'
              ;;
        *)
              cat /var/log/dpkg.log
              ;;
      esac
}

# attach to a tmux session or start a new session if one doesn't exist
function muxt() { tmux attach || tmux }
# bind above function to Ctrl+t
# ^q = pushline, \n = execute by entering a new line
bindkey -s '^[t' '^qmuxt\n'

# Create a new directory and enter it
function md() {
  mkdir -p "$@" && cd "$@"
}

# Search history with h $arg or just type h for full history
function h() { if [ -z "$*" ]; then history 1; else history 1 | egrep "$@"; fi; }

function vncc() { vncviewer "${1}":1 & }

function shr() { ssh root@"${1}" }
function shnr() { sshno root@"${1}" }

# print yum environment variables
function printyumenv() { python -c 'import yum, pprint; yb = yum.YumBase(); pprint.pprint(yb.conf.yumvar, width=1)'}

# start a vnc server on :99 using display :0
function start-vnc0() { x11vnc -display :0 -rfbport 5999 -repeat -noncache -q -bg & }

function extract-rpm() { rpm2cpio "$1" | cpio -idmv; }

function show-cert() { s openssl x509 -text -in "$1"; }

# remove host key for ssh
function rm-sshkey() {
  MATCH=$(sed -n "/$1/p" $HOME/.ssh/known_hosts)
  if [[ ! -z $MATCH ]]; then
    echo -e "\e[1;32m Matched Lines \e[0m"
    echo $MATCH
  else
    echo "No key found"
    return
  fi
  local CONFIRM=N
  echo "Delete? (y/N): " 
  read CONFIRM
  if [[ $CONFIRM == 'y' ]]; then
    sed -i "/$1/d" $HOME/.ssh/known_hosts
  else
    printf "replace aborted"
  fi
}

# SSH to a host when it becomes available
function sshup() { while $(ping -c 1 ${1} | grep -qi unreachable); do printf %s "."; sleep 1; done && ssh "$1"; }

# Most important functions
disapointed() { echo " ಠ_ಠ "; }
flip() { echo "（╯°□°）╯ ┻━┻"; }
shrug() { echo "¯\_(ツ)_/¯"; }
matrix() { echo -e "\e[1;40m" ; clear ; while :; do echo $LINES $COLUMNS $(( $RANDOM % $COLUMNS)) $(( $RANDOM % 72 )) ;sleep 0.05; done|awk '{ letters="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()"; c=$4; letter=substr(letters,c,1);a[$3]=0;for (x in a) {o=a[x];a[x]=a[x]+1; printf "\033[%s;%sH\033[2;32m%s",o,x,letter; printf "\033[%s;%sH\033[1;37m%s\033[0;0H",a[x],x,letter;if (a[x] >= $1) { a[x]=0; } }}' }

insert_sudo() { zle beginning-of-line; zle -U "s " }
zle -N insert-sudo insert_sudo
bindkey "^[s" insert-sudo

# Backup funciton
bu() { cp "$1" "$1".backup-`date +%y%m%d`; }

if [[ -d "${ZDOTDIR}"/zsh.d ]]; then
    for ZSH_FILE in $(ls -A "${ZDOTDIR}"/zsh.d/*.zsh); do
        source "${ZSH_FILE}"
    done
fi

hexip() {
  # if given a dotted ip, convert to hex
  if [[ $1 =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
    printf '%02X' $(echo ${1//./ }) ; echo
  # if given hex, convert to dotted ip
  elif [[ $1 =~ ^([0-9A-Fa-f]{2})*$ ]]; then
    printf "%d." $(echo $1 | sed 's/../0x& /g' | tr ' ' '\n' | tac) | sed 's/\.$/\n/'
  # if given hostname, output dotted ip and hex ip
  else
    gethostip -dx $1
  fi
}

if [[ -f "/usr/local/bin/virtualenvwrapper.sh" ]]; then
  source "/usr/local/bin/virtualenvwrapper.sh"
fi

# Curl to bash
c2b() {
  curl -L ${1} | s bash
}
export PATH="$HOME/.dotfiles/bin/packer:$HOME/.dotfiles/bin:$GOPATH/bin:$EC2_HOME/bin:$PATH"
command -v rbenv >/dev/null 2>&1 && eval "$(rbenv init -)"

# The next line updates PATH for the Google Cloud SDK.
if [[ -d $HOME/bin/google-cloud-sdk ]]; then
  source '/home/jgarr/bin/google-cloud-sdk/path.zsh.inc'
fi

# gcloud command completion
if [[ -d $HOME/src/gcloud-zsh-completion ]]; then
  fpath=($HOME/src/gcloud-zsh-completion/src/ $fpath)
  autoload -U compinit compdef
  compinit
fi
